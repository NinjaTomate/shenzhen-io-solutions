# Input variables
P_DETECT
P_TARGET_X
P_TARGET_Y

# Output variables
X_SCORE_1
X_SCORE_2

# Overview
 0 <= distance < 10;  4
10 <= distance < 20;  2
20 <= distance < 30;  1
30 <= distance     ; -2

Pythagorean distance = sqrt(|50 - x| ^ 2 + |50 - y| ^ 2)
  Definitely going to need to approximate that...

  0 < x < 100
  so...
  0 < |50 - x| < 50

Numbers they have:

29, 27 -> -2
67, 72 ->  1

We should probably look at numbers in a spreadsheet for better visualization/clarity

We probably don't need to use P_DETECT... but you can if you want
  Never mind, we do -- it's required in a first test case

# Gist
Use 2 controllers for scores and a controller for calculating shot value
  Score 1 counts for 4 detects, then waits for 4 detects, then flashes
      Might be too much code but that's for prototyping
  Score 2 waits for 4 detects, counts for 4 detects, then flashes
  Shot value waits for X signal, looks at x/y, determines value, replies with value over X signal

|   0,   0 |   0,  10 |   0,  20 |   0,  30 |   0,  40 |   0,  50 |   0,  60 |   0,  70 |   0,  80 |   0,  90 |   0, 100 |
|  10,   0 |  10,  10 |  10,  20 |  10,  30 |  10,  40 |  10,  50 |  10,  60 |  10,  70 |  10,  80 |  10,  90 |  10, 100 |
|  20,   0 |  20,  10 |  20,  20 |  20,  30 |  20,  40 |  20,  50 |  20,  60 |  20,  70 |  20,  80 |  20,  90 |  20, 100 |
|  30,   0 |  30,  10 |  30,  20 |  30,  30 |  30,  40 |  30,  50 |  30,  60 |  30,  70 |  30,  80 |  30,  90 |  30, 100 |
|  40,   0 |  40,  10 |  40,  20 |  40,  30 |  40,  40 |  40,  50 |  40,  60 |  40,  70 |  40,  80 |  40,  90 |  40, 100 |
|  50,   0 |  50,  10 |  50,  20 |  50,  30 |  50,  40 |  50,  50 |  50,  60 |  50,  70 |  50,  80 |  50,  90 |  50, 100 |
|  60,   0 |  60,  10 |  60,  20 |  60,  30 |  60,  40 |  60,  50 |  60,  60 |  60,  70 |  60,  80 |  60,  90 |  60, 100 |
|  70,   0 |  70,  10 |  70,  20 |  70,  30 |  70,  40 |  70,  50 |  70,  60 |  70,  70 |  70,  80 |  70,  90 |  70, 100 |
|  80,   0 |  80,  10 |  80,  20 |  80,  30 |  80,  40 |  80,  50 |  80,  60 |  80,  70 |  80,  80 |  80,  90 |  80, 100 |
|  90,   0 |  90,  10 |  90,  20 |  90,  30 |  90,  40 |  90,  50 |  90,  60 |  90,  70 |  90,  80 |  90,  90 |  90, 100 |
| 100,   0 | 100,  10 | 100,  20 | 100,  30 | 100,  40 | 100,  50 | 100,  60 | 100,  70 | 100,  80 | 100,  90 | 100, 100 |

 0 <= distance < 10;  4
10 <= distance < 20;  2
20 <= distance < 30;  1
30 <= distance     ; -2

(10, 10) = sqrt(1600 + 1600) = 56.6 (-2 points)
(20, 20) = sqrt(900 + 900) = 42.426 (-2 points)
(30, 30) = sqrt(900 + 900) = 28.28 (1 point)

Sooo instead of Euclidean coordinates, there is probably a radius threshold... right?

Oh, that's the distances... duh...

Well it's radially based so all you need is the greater of x and y
  Then you can figure out what distance it fits in
  Then map that to the point value

```
# Wait for and flush signal
# TODO: We can sleep/loop always and use a P pin to save 1 line
slx output
mov output null

# Find out which is farther x or y
tgt x y
+ mov x acc
- mov y acc

# If we are over 50, move to 0 - 50 range
tgt acc 50
+ sub 50

# Relocate x/y distance so we can cumulatively add points without lots of jumps
mov acc dat

# Reset points to -2 and add difference as it gets closer
mov -2 acc
tlt dat 30
+ add 3
tlt dat 20
+ add 1
tlt dat 10
+ add 2

# Output value
mov acc output
```

Damn, that's 16 lines of code, need to figure out something better...

# Implementation
So those `tlt` lines are wrong and actually won't work due to bad subtraction

We need `50 - x` for radial distance

```
# Wait for and flush signal
# TODO: We can sleep/loop always and use a P pin to save 1 line
slx output
mov output null

# Reset accumulator to 50
mov 50 acc

# Find out which is farther x or y
# acc = 50 - x (e.g. 50 - 100 -> -50, 50 - 0 -> 50)
tgt x y
+ sub x
- sub y

# If we are negative, flip our value
# acc = -1 * acc (e.g. -50 -> 50, 50 -> 50)
tlt acc 0
+ mul -1

# ...
```

Can we optimize for `dgt` with values?

 0 <= distance < 10; 40 < x <  60;  4
10 <= distance < 20; 30 < x <  70;  2
20 <= distance < 30; 20 < x <  80;  1
30 <= distance     ;  0 < x < 100; -2

I don't think we can...

Maybe we can save lines by doing 1 controller to calculate radial distance and another to add the damn points

 0 <= distance < 10; 40 < x <= 50;  4
10 <= distance < 20; 30 < x <= 40;  2
20 <= distance < 30; 20 < x <= 30;  1
30 <= distance     ;  0 < x <= 20; -2

40 <= x - 1 < 50;  4
30 <= x - 1 < 40;  2
20 <= x - 1 < 30;  1
 0 <= x - 1 < 20; -2

dgt...

4X -> 4 -> 4 +  0 ->  4
3X -> 3 -> 3 -  1 ->  2
2X -> 2 -> 2 -  1 ->  1
1X -> 1 -> 1 = -2 -> -2
0X -> 0 -> 1 = -2 -> -2

Or in linear form

4X -> 4 -> 4
3X -> 3 -> 3 - 1 ->  2
2X -> 2 -> 2 - 1 ->  1
1X -> 1 -> 1 - 1 ->  0 -> = -2 -> -2
0X -> 0 -> 1 - 1 -> -1 -> = -2 -> -2

Original:

```
slp: slx x0
mov x0 null
mov 50 acc
tgt p1 p0
+ sub p1
- sub p0
tgt acc 50
+ sub 50
mov acc dat
mov -2 acc
tlt dat 30
+ add 3
tlt dat 20
+ add 1
```
