# Input variables
X_RADIO_RX

# Output variables
P_MOTOR_X
P_MOTOR_Y
P_HARVEST

# Overview
Harvester location = `0, 0`
On radio signal
  Queue up new position `x, y` (from signal)

When queue isn't empty
  Move to next position in queue and harvest

Diagonal moves should be made when possible

Helper: Will never get packet for `0, 0`
Helper: Will never have more than 6 pending locations

# Gist
1 controller to read signals into RAM (queue, address 1)
1 controller to read from RAM (queue, address 2)
  Sends signals to X movement, Y movement, and handle harvest personally
1 controller for X movement (X pin -> on + sleep for `n`)
1 controller for Y movement (X pin -> on + sleep for `n`)

We thought about having signals queue back/forth with reader but we will likely miss out on `slx` signals due to sleeps or something

TODO: Probably going to run into trouble with keeping track of position but let's see how this goes...
TODO: Will probably hit queue flush states so need to reset to `0, 0` at some point or skip over `13 + 14` in RAM

First attempt (only signal to RAM and read from RAM):

```
# Save incoming signal
mov x0 acc

# If the signal isn't -999
teq acc -999
  # Save it to RAM (autoincrements)
- mov acc x2
- mov x0 x2

# Sleep
slp: slp 1
```

TODO: Improve this by writing directly to memory and using `tlt 1` instead of `teq 0`

```
# Save current position (originally use a `sub 2` variant but this is easier)
mov x1 acc

# If the next 2 positions are 0, 0, then reset position and sleep
teq x0 0
+ teq x0 0
+ mov acc x1
+ jmp slp

# Otherwise, reset index and "output" the 2 positions
mov acc x1
mov x0 dat
mov x0 dat

# Erase output positions to prevent looping
mov acc x1
mov 0 x0
mov 0 x0

# Sleep
slp: slp 1
```

Tried out `-999` but it feels like we're pushing the buck. Going to use `nop` to fix the solution with less cost

```
mov x0 x2
mov x0 x2
slp: slp 1
```

```
mov x1 acc
tcp x0 0
- jmp slp
+ mov acc x1
+ mov x0 dat
+ mov x0 dat
+ mov acc x1
+ mov 0 x0
+ mov 0 x0
mov acc x1
slp: slp 1
```

Never mind, we get 2 nops at most but run out of time =(

Tried out this logic but it fails due to (1) not being fast enough and (2) not handling [x, 0]

```
mov x1 acc
teq x0 -999
+ mov x0 null
+ jmp slp
teq x0 0
+ mov acc x1
+ jmp slp
mov acc x1
mov x0 dat
mov x0 dat
mov acc x1
mov 0 x0
mov 0 x0
slp: slp 1
```

TODO: What if we handle resetting values via writer so we can free up space for `nop`

Alright, this works. Yey.

We will need to write/read `-999` to/from RAM due to speed issues

```
# Save incoming signals to RAM (autoincrements)
mov x0 x2
mov x0 x2

# Save current position
mov x3 acc

# Erase next 2 slots (should be cleared as it's the 7th pending location)
mov 0 x2
mov 0 x2

# Reset to "current position"
mov acc x3

# Sleep
slp: slp 1
```

```
# Back up current position to `acc`
# DEV: This also delays us so incoming signal can be written to RAM
mov x1 acc

# If next location is `-999`, then ignore following `-999` and sleep
# DEV: We could have an implementation which resets `-999` to `0` but this is less code
teq x0 -999
+ mov x0 null
+ jmp slp

# Reset our position
mov acc x1

# If the next values are 0, 0 (i.e. no new values in queue), then reset our position and sleep
teq x0 0
+ teq x0 0
+ mov acc x1
+ jmp slp

# Reset our position and output x, y coordinates
mov acc x1
mov x0 dat
mov x0 dat

# Sleep
slp: slp 1
```

TODO: Explore a `tcp` branch with `-999`, `0`, and non-zeroes
  I think negatives with double ifs are broken though...

TODO: I wonder if we'll overwrite valid data with `-999` at some point...
   If we do run into it, the `mov x0 null` will become `mov acc x1` (position reset)
   and we'll need to update writer to detect/wipe `-999`

Motor positions need to tell harvest when they're done

So they should use 1 X pin to tell a harvestor controller via `slx`

Then harvester tells RAM reader to resume queue via `slx` itself too

Should prob explore that `tcp` branch so maybe we can remove need for harvester standalone...

So... `tcp` won't work but dual `tlt 1` will =D

Here's a revamp with support for no `-999` persisted in RAM

```
# Output incoming signals to RAM
mov x0 x2
mov x0 x2

# Move to freshly written position
# DEV: We use `mov + sub` instead of `sub` at head get data ready for reader ASAP
mov x3 acc
sub 2
mov acc x3

# If didn't write -999, then prepare to erase upcoming memory
teq x2 -999
- add 2

# Move to position (fresh position for -999, upcoming position for non -999)
mov acc x3

# Erase memory
mov 0 x2
mov 0 x2

# Reset position for new data
mov acc x3

# Wait
slp: slp 1
```

# TODO: We can probably skip overwriting `-999` with 0's and overwrite it on next iteration...

```
# Save current position in memory
mov x1 acc

# If we have 0, 0 or -999, -999, then reset position and wait for new data
tlt x0 1
+ tlt x0 1
+ mov acc x1
+ jmp slp

# Otherwise, reset position and output data
mov acc x1
mov x0 dat
mov x0 dat

# Sleep
slp: slp 1
```

And here's the reuse of `-999`:

```
# Output incoming signals to RAM
mov x0 x2
mov x0 x2

# Move to freshly written position
# DEV: We use `mov + sub` instead of `sub` at head get data ready for reader ASAP
mov x3 acc
sub 2
mov acc x3

# If we received -999, reset our position immediately
teq x2 -999
+ jmp reset

# Otherwise, ignore next value (other non -999)
mov x2 null

# Save our new position to reset to
mov x3 acc

# Erase upcoming data's position
mov 0 x2
mov 0 x2

# Reset position to allow write into "upcoming data" slots
reset: mov acc x3

# Sleep
slp 1
```

"No -999" has 1 less line of code but I think "-999 reuse" saves power due to `jmp` instead of writing 0's

TODO: Instead of decreasing and keeping track via loop
  Do a `slp` instead...

Initially did poor sleep logic via `add/sub` + `slp 1`

```
# Reset motor position
mov 50 p1

# Wait for signal
slx x1

# Save incoming target position
mov x1 dat

# If we are at target position, jump to done
loop: teq acc dat
+ jmp done

# Move motor in desired direction
tcp dat acc
- sub 1
- mov 0 p1
+ add 1
+ mov 100 p1

# Sleep for value
slp 1

# Continue looping
jmp loop

# Notify harvester of completion
done: mov 100 x2
```

Other one is similar...

```
# Wait for response from x and y motor controllers and flush their signals
slx x0
mov x0 null
slx x0
mov x0 null

# Perform harvest
gen p1 1 0
```

Soo things that are wrong:

- Should improve sleep logic by using `mul -1` instead of looping
- Queue shouldn't consume next slots until harvest is done so it should either own harvest logic or get signal from harvester
    - Based on our slots and layout, we can prob only have it be the harvester

We are honing in on solution

Latest iteration has harvest logic in RAM reader BUT it does `slx` which leads to 1 controller finishing before other one

We need to use something like P pin watcher to prevent this
  i.e. wait for motors to reset to 50, then harvest

Then resume queue (either via `slx` or logic in controller)

```
# Save current position in memory
mov x1 acc

# If we have 0, 0 or -999, -999, then reset position and wait for new data
tlt x0 1
+ tlt x0 1
+ mov acc x1
+ jmp slp

# Otherwise, reset position and output data
mov acc x1
mov x0 x3
mov x0 x2

# Wait for X motor to finish
slx x3
mov x3 null

# Wait for Y motor to finish
# DEV: We reuse its data for setting harvester to on so we can reuse `slp`
slx x2
mov x2 p0

# Let harvester run and reset it
slp: slp 1
mov 0 p0
```

```
# Reset motor position
mov 50 p1

# Wait for new position
slx x0

# Perform (target position - current position)
#   i.e. current position -> -1 * current positon -> -1 * current position + target position)
mul -1
add x0

# Update our motor position and sleep until it's done
tcp acc 0
- mov 0 p1
+ mov 100 p1
slp acc

# Notify harvester of completion
mov 100 x0
```

We tried a P watcher setup, it's close but we run out of lines to loop and no space for more controllers

We moved to using 1 X pin for both X/Y motors. Maybe we can do same for response but on a different pin to avoid waking other controller

```
mov x1 acc
tlt x0 1
+ tlt x0 1
+ mov acc x1
+ jmp slp
mov acc x1
mov x0 x3
mov x0 x3
loop: teq p0 50
+ teq p0 50
+ mov 100 x2
+ slp 1
+ mov 0 x2
slp: slp 1
```
