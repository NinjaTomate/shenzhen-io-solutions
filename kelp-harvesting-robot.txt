# Input variables
X_RADIO_RX

# Output variables
P_MOTOR_X
P_MOTOR_Y
P_HARVEST

# Overview
Harvester location = `0, 0`
On radio signal
  Queue up new position `x, y` (from signal)

When queue isn't empty
  Move to next position in queue and harvest

Diagonal moves should be made when possible

Helper: Will never get packet for `0, 0`
Helper: Will never have more than 6 pending locations

# Gist
1 controller to read signals into RAM (queue, address 1)
1 controller to read from RAM (queue, address 2)
  Sends signals to X movement, Y movement, and handle harvest personally
1 controller for X movement (X pin -> on + sleep for `n`)
1 controller for Y movement (X pin -> on + sleep for `n`)

We thought about having signals queue back/forth with reader but we will likely miss out on `slx` signals due to sleeps or something

TODO: Probably going to run into trouble with keeping track of position but let's see how this goes...
TODO: Will probably hit queue flush states so need to reset to `0, 0` at some point or skip over `13 + 14` in RAM

First attempt (only signal to RAM and read from RAM):

```
# Save incoming signal
mov x0 acc

# If the signal isn't -999
teq acc -999
  # Save it to RAM (autoincrements)
- mov acc x2
- mov x0 x2

# Sleep
slp: slp 1
```

TODO: Improve this by writing directly to memory and using `tlt 1` instead of `teq 0`

```
# Save current position (originally use a `sub 2` variant but this is easier)
mov x1 acc

# If the next 2 positions are 0, 0, then reset position and sleep
teq x0 0
+ teq x0 0
+ mov acc x1
+ jmp slp

# Otherwise, reset index and "output" the 2 positions
mov acc x1
mov x0 dat
mov x0 dat

# Erase output positions to prevent looping
mov acc x1
mov 0 x0
mov 0 x0

# Sleep
slp: slp 1
```

Tried out `-999` but it feels like we're pushing the buck. Going to use `nop` to fix the solution with less cost

```
mov x0 x2
mov x0 x2
slp: slp 1
```

```
mov x1 acc
tcp x0 0
- jmp slp
+ mov acc x1
+ mov x0 dat
+ mov x0 dat
+ mov acc x1
+ mov 0 x0
+ mov 0 x0
mov acc x1
slp: slp 1
```

Never mind, we get 2 nops at most but run out of time =(

Tried out this logic but it fails due to (1) not being fast enough and (2) not handling [x, 0]

```
mov x1 acc
teq x0 -999
+ mov x0 null
+ jmp slp
teq x0 0
+ mov acc x1
+ jmp slp
mov acc x1
mov x0 dat
mov x0 dat
mov acc x1
mov 0 x0
mov 0 x0
slp: slp 1
```

TODO: What if we handle resetting values via writer so we can free up space for `nop`

Alright, this works. Yey.

We will need to write/read `-999` to/from RAM due to speed issues

```
# Save incoming signals to RAM (autoincrements)
mov x0 x2
mov x0 x2

# Save current position
mov x3 acc

# Erase next 2 slots (should be cleared as it's the 7th pending location)
mov 0 x2
mov 0 x2

# Reset to "current position"
mov acc x3

# Sleep
slp: slp 1
```

```
# Back up current position to `acc`
# DEV: This also delays us so incoming signal can be written to RAM
mov x1 acc

# If next location is `-999`, then ignore following `-999` and sleep
# DEV: We could have an implementation which resets `-999` to `0` but this is less code
teq x0 -999
+ mov x0 null
+ jmp slp

# Reset our position
mov acc x1

# If the next values are 0, 0 (i.e. no new values in queue), then reset our position and sleep
teq x0 0
+ teq x0 0
+ mov acc x1
+ jmp slp

# Reset our position and output x, y coordinates
mov acc x1
mov x0 dat
mov x0 dat

# Sleep
slp: slp 1
```

TODO: Explore a `tcp` branch with `-999`, `0`, and non-zeroes
  I think negatives with double ifs are broken though...

TODO: I wonder if we'll overwrite valid data with `-999` at some point...
   If we do run into it, the `mov x0 null` will become `mov acc x1` (position reset)
   and we'll need to update writer to detect/wipe `-999`

Motor positions need to tell harvest when they're done

So they should use 1 X pin to tell a harvestor controller via `slx`

Then harvester tells RAM reader to resume queue via `slx` itself too

Should prob explore that `tcp` branch so maybe we can remove need for harvester standalone...

So... `tcp` won't work but dual `tlt 1` will =D

Here's a revamp with support for no `-999` persisted in RAM

```
# Output incoming signals to RAM
mov x0 x2
mov x0 x2

# Move to freshly written position
# DEV: We use `mov + sub` instead of `sub` at head get data ready for reader ASAP
mov x3 acc
sub 2
mov acc x3

# If didn't write -999, then prepare to erase upcoming memory
teq x2 -999
- add 2

# Move to position (fresh position for -999, upcoming position for non -999)
mov acc x3

# Erase memory
mov 0 x2
mov 0 x2

# Reset position for new data
mov acc x3

# Wait
slp: slp 1
```

# TODO: We can probably skip overwriting `-999` with 0's and overwrite it on next iteration...

```
# Save current position in memory
mov x1 acc

# If we have 0, 0 or -999, -999, then reset position and wait for new data
tlt x0 1
+ tlt x0 1
+ mov acc x1
+ jmp slp

# Otherwise, reset position and output data
mov acc x1
mov x0 dat
mov x0 dat

# Sleep
slp: slp 1
```

And here's the reuse of `-999`:

```
# Output incoming signals to RAM
mov x0 x2
mov x0 x2

# Move to freshly written position
# DEV: We use `mov + sub` instead of `sub` at head get data ready for reader ASAP
mov x3 acc
sub 2
mov acc x3

# If we received -999, reset our position immediately
teq x2 -999
+ jmp reset

# Otherwise, ignore next value (other non -999)
mov x2 null

# Save our new position to reset to
mov x3 acc

# Erase upcoming data's position
mov 0 x2
mov 0 x2

# Reset position to allow write into "upcoming data" slots
reset: mov acc x3

# Sleep
slp 1
```

"No -999" has 1 less line of code but I think "-999 reuse" saves power due to `jmp` instead of writing 0's

TODO: Instead of decreasing and keeping track via loop
  Do a `slp` instead...

Initially did poor sleep logic via `add/sub` + `slp 1`

```
# Reset motor position
mov 50 p1

# Wait for signal
slx x1

# Save incoming target position
mov x1 dat

# If we are at target position, jump to done
loop: teq acc dat
+ jmp done

# Move motor in desired direction
tcp dat acc
- sub 1
- mov 0 p1
+ add 1
+ mov 100 p1

# Sleep for value
slp 1

# Continue looping
jmp loop

# Notify harvester of completion
done: mov 100 x2
```

Other one is similar...

```
# Wait for response from x and y motor controllers and flush their signals
slx x0
mov x0 null
slx x0
mov x0 null

# Perform harvest
gen p1 1 0
```

Soo things that are wrong:

- Should improve sleep logic by using `mul -1` instead of looping
- Queue shouldn't consume next slots until harvest is done so it should either own harvest logic or get signal from harvester
    - Based on our slots and layout, we can prob only have it be the harvester

We are honing in on solution

Latest iteration has harvest logic in RAM reader BUT it does `slx` which leads to 1 controller finishing before other one

We need to use something like P pin watcher to prevent this
  i.e. wait for motors to reset to 50, then harvest

Then resume queue (either via `slx` or logic in controller)

```
# Save current position in memory
mov x1 acc

# If we have 0, 0 or -999, -999, then reset position and wait for new data
tlt x0 1
+ tlt x0 1
+ mov acc x1
+ jmp slp

# Otherwise, reset position and output data
mov acc x1
mov x0 x3
mov x0 x2

# Wait for X motor to finish
slx x3
mov x3 null

# Wait for Y motor to finish
# DEV: We reuse its data for setting harvester to on so we can reuse `slp`
slx x2
mov x2 p0

# Let harvester run and reset it
slp: slp 1
mov 0 p0
```

```
# Reset motor position
mov 50 p1

# Wait for new position
slx x0

# Perform (target position - current position)
#   i.e. current position -> -1 * current positon -> -1 * current position + target position)
mul -1
add x0

# Update our motor position and sleep until it's done
tcp acc 0
- mov 0 p1
+ mov 100 p1
slp acc

# Notify harvester of completion
mov 100 x0
```

We tried a P watcher setup, it's close but we run out of lines to loop and no space for more controllers

We moved to using 1 X pin for both X/Y motors. Maybe we can do same for response but on a different pin to avoid waking other controller

```
mov x1 acc
tlt x0 1
+ tlt x0 1
+ mov acc x1
+ jmp slp
mov acc x1
mov x0 x3
mov x0 x3
loop: teq p0 50
+ teq p0 50
+ mov 100 x2
+ slp 1
+ mov 0 x2
slp: slp 1
```

So we have something that works but it doesn't align with expectations

The expectations want an eager/running motor/harvest
  so we keep on moving and harvest as we sweep by

Ours stops and harvests then goes

The logic is oddly the same as dual `slx` on harvester except now they `slx` on the same pin and the motors share another pin (using Y as top motor and X as bottom since we have no space for distance extending)

Thinking about how to transfer next queued location to motors...

So motors don't keep running, they both need to hit location
  We mostly need to transmit before saying "harvest" and sleeping

I was thinking about sleeping the reader for the greater of the 2 "sleep" values

We are actually really close:

- We need to re-evaluate queue on both motor finish
- We also need to kick off harvest action for 1s

Due to lines of code, I think it should be a separate controller for harvester

We are out of pins though on RAM reader due to inconsistent timings for motor getting values in what order

So we need to use P pins or figure out backchannels

Maybe don't wait for `slx` at all and do that greatest value thing?

- Calculate sleep time on controllers
- Send back
- Find greater 1 of 2
- Sleep for that long
- Go to next

Need to trigger harvester still... but let's cross that bridge later

Can't do calculation in reader (too many lines of code)

```
next: mov x1 acc
tlt x0 1
+ tlt x0 1
+ mov acc x1
+ jmp slp
mov acc x1
mov x0 x3
mov x0 x2
mov x3 acc
mov x2 dat
tcp dat acc
+ slp dat
jmp next
slp: slp 1
```

But can do it in harvester and tell controller value via P

Closing in now, we have an off by one timing in second test suite

Probably due to a `slp 1` due to P annoyances =/
  Might be able to solve it by reusing `x2` with a preceding `999` packet or something

Reader:

```
# Same output logic as before
next: mov x1 acc
tlt x0 1
+ tlt x0 1
+ mov acc x1
+ jmp slp
mov acc x1
mov x0 x3
mov x0 x2

# After outputting signals, wait for P pin to be filled
slp 1

# Sleep for allotted time until next harvest
slp p0

# Look at queue again
jmp next

Sleep
slp: slp 1
```

Motor logic. Fixed up from before :+1:

```
# Reset motor position
mov 50 p1

# Wait for signal from reader
slx x0

# Load current position into acc as (-1 * position)
mov dat acc
mul -1

# Save target position to dat
mov x0 dat

# Calculate distance to position (target - current)
add dat

# Compare against distance
#   If 0, don't touch motor (although not needed)
tcp acc 0
  # If < 0, move motor in reverse and adjust acc to be absolute value
- mov 0 p1
- mul -1
  # If > 0, move motor in forward
+ mov 100 p1

# Output sleep duration (absolute value of distance)
mov acc x3

# Sleep for duration
slp acc
```

Harvester:

```
# Wait for signal
slx x0

# Save the 2 values
mov x0 acc
mov x0 dat

# Determine which value is greater and store it in `acc`
#   i.e. we want to sleep for longest period
tgt dat acc
+ mov dat acc

# Subtract 1 for off-by-one errors
# TODO: We thought this would be for `slp 1` on reader but no idea why for our own sleep
#   Maybe that's the off by one and we need an `add 1`
sub 1

# Output next harvest time to P
mov acc p0

# Sleep until next harvest time
slp acc

# Perform harvest
gen p1 1 0
```

Look at "Almost done, off by one"

What if we loop until P !=0 for pin sniffer?
  Is that even the problem?

Nope, that didn't solve it

```
next: mov x1 acc
tlt x0 1
+ tlt x0 1
+ mov acc x1
+ jmp slp
mov acc x1
mov x0 x3
mov x0 x2

# New code, wait for 100 to be unset
loop: teq p0 100
+ jmp loop
slp p0

# Sleep for 1 anyway due to waiting for harvest completion o_O
slp 1
jmp next
slp: slp 1
```

```
# New code, set 100 as flag
mov 100 p0

slx x0
mov x0 acc
mov x0 dat
tgt dat acc
+ mov dat acc
sub 1
mov acc p0
slp acc
gen p1 1 0
```

Oh fuck... we missed a case...

The off by one is going to a kelp location but passing over a square further down the queue

We need to restructure the code to support that

Probably have the motors request target location from reader or something

And have harvest controller constantly ask queue if we are over any squares
  Maybe expose current position via P on motors

Last touch "Almost done, while true"

Notes from this morning:

- Writer probably can't access P due to distance
- Update reader to loop full cycles and compare values (P from motors? or maybe they always output X), notify harvester on match, and tell notors to move to X, Y every 1 second (only moves by 1 closer to that unit to always get fresh location)

P output from motor feels promising

Although, we really could use X for return always...
  and always output on 1 s but would need to handle -999 in motors

Getting a late start reading though. Somehow it's getting -999 early while writer should be 1 OP ahead

Okay, we have progress but are missing a few things:

- Not unsetting completed entries (this means one we complete in transit or on arrival)
  - Should be reset to `-999` for sane skipping
  - But that doesn't really work with current code...
  - Needs more thought...
- Harvester isn't wired up, need to explore reusing an X pin me thinks
  But then we don't want to steal the motor's signal
  It feels like we need yet another controller...
  and somehow a third set of pins for RAM

Maybe we can offload harvest checking
  Like loop over RAM, ask harvester if it's a match, and then it replies with 0 or 1
    But we still have pin issue amirite?

Okay, code docs first...

Writer:

```
# Output data first
mov x2 x0
mov x2 x0

# Look at freshly written data
mov x1 acc
sub 2
mov acc x1

# If it was -999, move back to position so we overwrite it on next read
teq x0 -999
+ jmp reset

# Continue to next position
mov x0 null

# Store new position to move back to for next writes
mov x1 acc

# Clear out old data with `-999` to prevent accidental reads
mov -999 x0
mov -999 x0

# Move to new position for next writes
reset: mov acc x1

# Sleep
slp 1
```

Reader:

```
# Store original position read from
mov x1 acc

# If the data we are reading is -999, ignore it
teq x0 -999
+ jmp pre

# Otherwise, go back to original position
mov acc x1

# Tell motors where to move to
mov x0 x3
mov x0 x2

# Go back to original position
# DEV: This is to handle reading only 1 slot for -999
#   We would be fine with the 2 slots ahead for `mov`
pre: mov acc x1

# If our X coordinate matches motor coordinates,
#   Set up half of boolean for harvester
# TODO: `mov 100 dat` is never reset
loop: teq x0 p1
+ mov 100 dat

# If our Y coordinate matches, then tell harvester about our matching X coordinate (signal itself tells them Y matched)
teq x0 p0
+ mov dat null

# If we aren't at our original position, keep looping
teq x1 acc
- jmp loop

# Sleep
slp: slp 1
```

Motor:

```
# Reset motor position
mov 50 p1

# Wait for location to move to
slx x0

# Comapre current location to target location
#   Adjust current location and motor accordingly
tcp acc x0
- add 1
- mov 100 p1
+ sub 1
+ mov 0 p1

# Expose new location via P
mov acc p0

# Sleep
slp 1
```

So maybe we always read out non -999 values to controller
  and that replies with with 0 or 1 to erase it/not

The controller then forwards first X/Y to motors
  Respond with X/Y saying that match
    On match in eraser, notify harvester?
    We can't do it in here as we have to accept incoming signals
      whereas harvester can reset RAM position and emit
Then it compares remaining ones to current X/Y position
  Reponse with X/Y match/not

This should solve pin problem, unsure we have layout for it though...

Need to handle -999 skipping in current RAM reader
  Need to somehow signal end of loop?

Code is looking good but we have no way of distinguishing target location from comparison locations
  So maybe 2 controllers?

  1 to update motors
  1 to check harvest OK

I feel like outputting that to controllers won't save us much
  We wanted to do special signals but we have no space for unsetting matched locations

Current loop logic:

```
# Save original position
mov x1 acc

# If we are reading a -999, -999 or 0, 0 pair
#  then jump to original position check
loop: tlt x0 1
+ tlt x0 1
+ jmp check

# Otherwise, move back to original position
#   and output data
mov acc x1
mov x0 x3
mov x0 x3

# If we are done walking over the entirety of the RAM, go to sleep
# TODO: We can combine those jumps into a `- jmp loop`
check: teq x1 acc
+ jmp slp

# Otherwise, loop
jmp loop

# Sleep
slp: slp 1
```

Tried out sending position to motor parser but it's so much code:

```
mov x1 dat
mov 0 acc
loop: tlt x0 1
+ tlt x0 1
+ jmp check
mov acc x1
mov acc x3
mov dat x3
mov x0 x3
mov x0 x3
check: teq x1 dat
- add 2
- jmp loop
slp: slp 1
```

Maybe we let parser read from pin directly and give it a special signal to tell it to read from the signal?

Went forward with address tracking but realizing it's quite silly

We should always send `-999` and `0` so we don't have silly back tracking logic and send a `-1` flag at the start of the request

Then the parser can see the `-1` and act accordingly

`-1` will require too many lines of code...
  If we go to more controllers, we get bad layout

Maybe 1 controller to update motors and another to check motor positions?

Code updates for `-1`

```
mov x1 dat
mov -1 x3
loop: mov x0 x3
mov x0 x3
check: teq x1 dat
- jmp loop
slp: slp 1
```

```
slp: slx x1
mov x1 dat
teq dat -1
+ mov dat acc
+ jmp slp
teq acc -1
+ mov dat x3
+ mov x3 acc
+ mov x1 x2
+ mov x2 dat
- mov dat null
- mov x1 null
```
