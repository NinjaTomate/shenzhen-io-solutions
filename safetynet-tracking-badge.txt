# Input variables
# P_RADAR_SYNC
# P_RADAR_PING
# X_RADIO_RX (non-blocking)

# Output variables
# X_RADIO_TX
# P_SPEAKER

# First iteration
## Notes
Packet =
  [1, length, audio for $length units...]
  OR
  [2, badge id] -> Send back sector

Ping and sector are in donut for some reason, let's unroll that...

|                   | SYNC_0 |  20 |  40 |  60 |  80 | 100 |
|-------------------|--------|-----|-----|-----|-----|-----|
| 80 <= PING <= 100 |    100 | 100 | 100 | 100 | 100 | 100 |
| 50 <  PING <   80 |    600 | 200 | 201 | 202 | 203 | 204 |
| 0  <= PING <= 50  |    600 | 700 | 700 | 700 | 700 | 700 |

Logic which should work for ping/sync calc

# Complete row 80 <= PING <= 100
if PING >= 80 (i.e. > 79)
  set 100
  jmp SLEEP

# Complete column SYNC_0 (excluding first row)
if SYNC === 0
  set 600
  jmp SLEEP

# Complete row 0 <= PING <= 50 (excluding first column)
if PING <= 50 (i.e < 51)
  set 700
  jmp SLEEP

# Complete remaining 200 - 204 values
# Derive offset of 0, 1, ..., 4 for 200 from SYNC
acc = sync (e.g. 20, 40, ..., 100)
acc -= 20 (e.g. 0, 20, ..., 80)
dgt 1 acc (e.g. 0, 2, ..., 8)
  Ugh, how do we divide...
  Oh, simpler... loop and subtract until data is 0

acc = sync (e.g. 20, 40, ... 100)
acc -= 20 (initial offset) -- (e.g. 0, 20, ..., 80)
LOOP:
  if acc > 0:
    acc -= 21 (e.g. 0, -1, -2, ..., -4)
    LOOP
acc *= -1 (e.g. 0, 1, 2, ..., 4)
acc += 200 (e.g. 200, 201, 202, ..., 204)
set acc

We explored/verified that DX300 normalizes 50 to 100 and 49 to 0 so we won't need to worry about extra P pins

Nvm, we need it... fuck...

Oh, and we needed to output on X due to >= 100 anyway so nvm =P

---------

Cool, we got tracker working except for persisting ping signal
  We will likely need another controller for that since we are out of space

Logic is same as above

- 1 MC6000 for non-LOOP part
- 1 MC6000 for LOOP part

Both write to same X channel

**Non-LOOP:**

```
# If PING >= 80, send 100 and stop
tgt p0 79
+ mov 100 x3
+ jmp SLEEP

# If SYNC === 0, send 600 and stop
teq p1 0
+ mov 600 x3
+ jmp SLEEP

# If PING <= 50, send 700 and stop
tlt p0 51
+ mov 700 x3
+ jmp SLEEP

# Load SYNC into memory
mov p1 acc

# Subtract 20 (as part of logic)
sub 20
  # TODO: We can free up `sub 20` by adding `199` instead of `200` later one
     This is due to 21 offsets

# Forwrad adjusted SYNC
mov acc x2
SLEEP: slp 1
```

**LOOP:**

```
# Wait for signal
slx x2

# Load adjusted SYNC
mov x2 acc

LOOP:
# Remove -21 until going below 0
tgt acc 0
+ sub 21
+ jmp LOOP

# Recover -1 overflows as offset
mul -1

# Add to 200
add 200

# Export value
mov acc x3
```

----

Yep, as expected we could move `sub 20` into `add 200` by making it `add 199`
  which freed up more lines

We now have a straightforward PING tracker

```
# NEW: Save PING for future reference
tgt p0 0
+ mov p0 dat

# NEW: Load from saved PING instead of PING pin
tgt dat 79
+ mov 100 x3
+ jmp SLEEP
teq p1 0
+ mov 600 x3
+ jmp SLEEP

# NEW: Load from saved PING instead of PING pin
tlt dat 51
+ mov 700 x3
+ jmp SLEEP

# NEW: Write SYNC directly to `x2`
# DEV: This saves 1 pin for LOOP controller and let's it know when to start
mov p1 x2
SLEEP: slp 1
```

```

slx x2
mov x2 acc
LOOP:
tgt acc 0
+ sub 21
+ jmp LOOP
mul -1
# NEW: Use `add 199` to account for `20` being set to `-1` then `1`
#   and we want `200`
add 199
mov acc x3
```
