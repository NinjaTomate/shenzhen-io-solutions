# Input variables
# P_IN_1
# P_IN_5
# P_IN_12
# X_PRICE

# Output variables
# P_BELL
# P_OUT_1
# P_OUT_5

# Gist
Add P_IN_* to TOTAL
If TOTAL over X_PRICE
  Ring bell for 4 seconds
  Subtract X_PRICE from TOTAL
  LOOP:
    If TOTAL >= 5
        TOTAL -= 5
        OUT_5 += 1
        SLEEP for 1 second
        LOOP
    If TOTAL >= 1
        TOTAL -= 1
        OUT_1 += 1
        SLEEP for 1 second
        LOOP

# Components
After visual exploration
  and problems with looping/sleeping and not hearing input

- 1 MC4000 to convert P_IN_1/5 to X_IN_COIN
- 1 MC4000 to read P_IN_12, X_IN_COIN, and trigger bell/output controllers
- 1 MC4000 to ring bell for 4 seconds (what a waste)
- 1 MC4000 to output coins

# Code
## Controller 1 (MC4000)
# If we have a 1 or 5 coin, send its info to Controller 2
# DEV: We use `jmp` as we lack if/else and we need to write to `X_IN_COIN` always
teq P_IN_1 100
+ mov 1 X_IN_COIN
+ jmp SLEEP
teq P_IN_5 100
+ mov 5 X_IN_COIN
+ jmp SLEEP
mov 0 X_IN_COIN

SLEEP:
slp 1

## Controller 2 (MC4000)
# Initialize with price as total
# DEV: We are using subtraction due to `tgt`
#   not being able to do equality and price is dynamic
@mov X_PRICE TOTAL

# Remove coins from total
sub X_IN_COIN
teq P_IN_12 100
+ sub 12

# If we are <= 0, trigger bell, coin dispenser, and reset counter
tgt TOTAL 0
+ mov 100 X_BELL_SIG
+ mov TOTAL X_COIN_SIG
+ mov X_PRICE TOTAL

## Controller 3 (MC4000)
# When we get a bell signal
slx X_BELL_SIG

# Turn on bell
mov 100 P_BELL

# Sleep for 4 seconds
slp 4

# Turn off bell
mov 0 P_BELL

## Controller 4 (MC4000)
# When we get a coin signal
slx X_COIN_SIG

# Save our total
mov X_COIN_SIG acc

# Loop and dispense coins
LOOP:
    # If we have over 5 due, dispense 5 and loop
    tlt TOTAL 5
    + mov 100 X_COIN_OUT # 5x1, 1x0, N/Ax0
    + slp 1
    + jmp LOOP
    tlt TOTAL 1
    + mov 010 X_COIN_OUT # 5x1, 1x0, N/Ax0
    + slp 1
    + jmp LOOP
