# Input variables
# P_IN_1
# P_IN_5
# P_IN_12
# X_PRICE

# Output variables
# P_BELL
# P_OUT_1
# P_OUT_5

# Gist
Add P_IN_* to TOTAL
If TOTAL over X_PRICE
  Ring bell
  Subtract X_PRICE from TOTAL
  Loop:
    If TOTAL >= 5
        TOTAL -= 5
        OUT_5 += 1
        LOOP
    If TOTAL >= 1
        TOTAL -= 1
        OUT_1 += 1
        LOOP

# Components
After visual exploration:

- 1 MC4000 to convert P_IN_1/5 to X_IN_COIN
- 1 MC6000 to read P_IN_12, X_IN_COIN + perform logic
- 1 DX300 to multiplex X signal to outputs

# Code
## Controller 1 (MC4000)
# If we have a 1 or 5 coin, send its info to Controller 2
# DEV: We use `jmp` as we lack if/else and we need to write to `X_IN_COIN` always
teq P_IN_1 100
+ mov 1 X_IN_COIN
+ jmp SLEEP
teq P_IN_5 100
+ mov 5 X_IN_COIN
+ jmp SLEEP
mov 0 X_IN_COIN

SLEEP:
slp 1

## Controller 2 (MC6000)
# Initialize with price as total
# DEV: We are using subtraction due to `tgt`
#   not being able to do equality and price is dynamic
@mov X_PRICE TOTAL

# Remove coins from total
sub X_IN_COIN
teq P_IN_12 100
+ sub 12

# If we are > 0, continue to sleep
tgt TOTAL 0
- jmp SLEEP

# Ring our bell
mov 1 X_BELL

# Loop and dispense coins
LOOP:
    # If we have over 5 due, dispense 5 and loop
    tlt TOTAL 5
    + mov 100 X_COIN_OUT # 5x1, 1x0, N/Ax0
    + slp 1
    + jmp LOOP
    tlt TOTAL 1
    + mov 010 X_COIN_OUT # 5x1, 1x0, N/Ax0
    + slp 1
    + jmp LOOP

# Reset counter
mov X_PRICE TOTAL

SLEEP:
slp 1

## Controller 3 (MC4000)
# When we get a bell signal
slx X_BELL

# Turn on bell
mov 100 P_BELL

# Sleep for 4 seconds
slp 4

# Turn off bell
mov 0 P_BELL
