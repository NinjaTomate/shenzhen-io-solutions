# Input variables
# P_X
# P_Y

# Output variables
# P_POWER

# Interpretation of sheet:
# When P_X < 20, P_POWER = 30
# When 20 <= P_X < 40, P_POWER = 0
# When 40 <= P_X < 60
#   If 40 <= P_Y < 80, P_POWER = 50
#   ELSE, P_POWER = 0
# When 60 <= P_X < 80
#   If 40 <= P_Y < 80, P_POWER = 80
#   ELSE, P_POWER = 30
# When 80 <= P_X, P_POWER = 30

# Observation:
When 40 <= X < 100, POWER = X_POWER + Y_POWER
  i.e. 40 <= X < 60, X_POWER = 0
       60 <= X     , X_POWER = 30
             Y < 40, Y_POWER = 0
       40 <= Y < 80, Y_POWER = 50
       80 <= Y     , Y_POWER = 0

# Requirements:
We need 3 different P pins so at least 2 controllers

# Gist:
## Controller 1
Convert P_X and P_Y to X_X and X_Y

## Controller 2
Implement logic with X_X and X_Y

# Proof of concept
## Controller 1
# Convert P_X and P_Y to X_X and X_Y
mov P_X X_X
mov P_Y X_Y

# Controller 2
# Save X_X to ACC
mov X_X ACC

# If X_X (ACC) is under 20, then output 30
tlt X_X__ACC 20
+ mov P_POWER 30
+ jmp SLEEP

# If X_X (ACC) is under 60, set `dat` to 0 (X_POWER)
# Otherwise, set `dat` to 30 (X_POWER)

# Save X_Y to ACC

# If X_Y (ACC) is over 40 AND under 80
    # Move `dat` (X_POWER) to `acc`
    # Add 50
    # Output `acc` as P_POWER
# Otherwise, output `dat` as P_POWER
# Otherwise, set `dat` to 30 (X_POWER)

SLEEP:
slp 1
