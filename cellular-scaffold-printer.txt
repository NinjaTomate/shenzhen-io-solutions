# Input variables
X_DATA

# Output variables
P_MOTOR_X
P_MOTOR_Y
P_VALVE_ALPHA
P_VALVE_BETA
P_VALVE_PSI

# Gist
8 different pattern types
Get a 6 value packet that outputs different rows
Get -1 to reset printer position

This feels a lot like sandwich assembler...

Reset packet never arrives while print job is in progress

From past Reddit browsings, they said X inputs can be slept and not flushed. It looks like they are right o_o

# First iteration
Reading from queue works:

Started with a P pin but thinking it's more trouble than it's worth (saves us a register but do we need to yet?)

```
slp: slx x1
mov x1 acc
teq acc -1
+ mov 100 p1
+ jmp slp
mov acc p1
mov 5 acc
loop: slp 6
mov x1 p1
sub 1
teq acc 0
- jmp loop
```

Oh fuck... I think they want us to be able to write patterns in reverse too... Ugh...

Probably sanest to have a controller that returns value based on position and pattern
  Then the motor or something tracks direction and position

Let's start simple though

Print the "2" pattern via a DX300

A `mul -1` is a great way to flip incrementers unfortunately it uses `acc` itself

We'll prob need to use ROM... not sure how

Rows "1"/4/5 share alphas
Rows 4/6 show psi

Psi are super infrequent -- only 4/6

So let's write up the data

Maybe we can do something with X*10 + Y or Y*10 + X indicies

Naive code:

```
slx x1
mov x1 dat
mov 000 x3
teq dat 1
+ mov 100 x3
teq dat 2
+ mov 010 x3
```

|   | 0 | 1 | 2 | 3 | 4 | 5 |
| 0 | - | - | - | - | - | - |
| 1 | a | a | a | a | a | a |
| 2 | b | b | b | b | b | b |
| 3 | a | b | a | b | a | b |
| 4 | c | a | a | c | a | c |
| 5 | - | a | a | - | a | - |
| 6 | c | - | - | c | - | c |
| 7 | - | a | - | - | - | - |
| 8 | - | - | - | - | b | - |

|   | 0    | 1    | 2    | 3    | 4    | 5    |
| 0 | 00 - | 10 - | 20 - | 30 - | 40 - | 50 - |
| 1 | 01 a | 11 a | 21 a | 31 a | 41 a | 51 a |
| 2 | 02 b | 12 b | 22 b | 32 b | 42 b | 52 b |
| 3 | 03 a | 13 b | 23 a | 33 b | 43 a | 53 b |
| 4 | 04 c | 14 a | 24 a | 34 c | 44 a | 54 c |
| 5 | 05 - | 15 a | 25 a | 35 - | 45 a | 55 - |
| 6 | 06 c | 16 - | 26 - | 36 c | 46 - | 56 c |
| 7 | 07 - | 17 a | 27 - | 37 - | 47 - | 57 - |
| 8 | 08 - | 18 - | 28 - | 38 - | 48 b | 58 - |

|   |  0   |  1   |  2   |  3   |  4   |  5   |
| 0 | 00 - | 01 - | 02 - | 03 - | 04 - | 05 - |
| 1 | 10 a | 11 a | 12 a | 13 a | 14 a | 15 a |
| 2 | 20 b | 21 b | 22 b | 23 b | 24 b | 25 b |
| 3 | 30 a | 31 b | 32 a | 33 b | 34 a | 35 b |
| 4 | 40 c | 41 a | 42 a | 43 c | 44 a | 45 c |
| 5 | 50 - | 51 a | 52 a | 53 - | 54 a | 55 - |
| 6 | 60 c | 61 - | 62 - | 63 c | 64 - | 65 c |
| 7 | 70 - | 71 a | 72 - | 73 - | 74 - | 75 - |
| 8 | 80 - | 81 - | 82 - | 83 - | 84 b | 85 - |

For us to store that in ROM, (rows 4-6) it would be 18 entries

Looked at meat based printer again, and now it's clicked

We had 2 ROM for that

We can use a ROM for columns 1, 2, 4. These are all verticall same except for (3,1), (7,1), and (8,4)

We can use another ROM for columns 0, 3, 5. These are all vertically same except for (3, 0)

1, 2, 4 ROM:

|   | Base (2) | 1   | 4   |
|---|----------|-----|-----|
| 0 | -        | -   | -   |
| 1 | a        | a   | a   |
| 2 | b        | b   | b   |
| 3 | a        | b * | a   |
| 4 | a        | a   | a   |
| 5 | a        | a   | a   |
| 6 | -        | -   | -   |
| 7 | -        | a * | -   |
| 8 | -        | -   | b * |

0, 3, 5 ROM:

|   | Base (3) | 5 | 0   |
|---|----------|---|-----|
| 0 | -        | - | -   |
| 1 | a        | a | a   |
| 2 | b        | b | b   |
| 3 | b        | b | a * |
| 4 | c        | c | c   |
| 5 | -        | - | -   |
| 6 | c        | c | c   |
| 7 | -        | - | -   |
| 8 | -        | - | -   |

If we ignore `0` in both cases and combine them, then we get:

1, 2, 4 ROM:

|        | Base (2) | 1   | 4   |
|--------|----------|-----|-----|
| 0 -> X | -        | -   | -   |
| 1 -> 0 | a        | a   | a   |
| 2 -> 1 | b        | b   | b   |
| 3 -> 2 | a        | b * | a   |
| 4 -> 3 | a        | a   | a   |
| 5 -> 4 | a        | a   | a   |
| 6 -> X | -        | -   | -   |
| 7 -> X | -        | a * | -   |
| 8 -> X | -        | -   | b * |

0, 3, 5 ROM:

|        | Base (3) | 5 | 0   |
|--------|----------|---|-----|
| 1 -> 5 | a        | a | a   |
| 2 -> 6 | b        | b | b   |
| 3 -> 7 | b        | b | a * |
| 4 -> 8 | c        | c | c   |
| 5 -> X | -        | - | -   |
| 6 -> 9 | c        | c | c   |
| 7 -> X | -        | - | -   |
| 8 -> X | -        | - | -   |

Cleaned up:


| 1 -> 0 | a |
| 2 -> 1 | b |
| 3 -> 2 | a |
| 4 -> 3 | a |
| 5 -> 4 | a |
| 1 -> 5 | a |
| 2 -> 6 | b |
| 3 -> 7 | b |
| 4 -> 8 | c |
| 6 -> 9 | c |

But now we have to think of code... but my sleep schedule has gotten wrecked recently so I'm going to stop here

I think we lost track of ourselves here. We can't strip out 0 rows without logic which bloats our code. Let's trip out rows 7/8 and assume they are 0 unless we are in the appropriate column override. That should fit everything into ROM:

|        | Base (2) | 1   | 4   |
|--------|----------|-----|-----|
| 0 -> 0 | -        | -   | -   |
| 1 -> 1 | a        | a   | a   |
| 2 -> 2 | b        | b   | b   |
| 3 -> 3 | a        | b * | a   |
| 4 -> 4 | a        | a   | a   |
| 5 -> 5 | a        | a   | a   |
| 6 -> 6 | -        | -   | -   |
| 7 -> X | -        | a * | -   |
| 8 -> X | -        | -   | b * |

0, 3, 5 ROM:

|         | Base (3) | 5 | 0   |
|---------|----------|---|-----|
| 0 -> 7  | -        | - | -   |
| 1 -> 8  | a        | a | a   |
| 2 -> 9  | b        | b | b   |
| 3 -> 10 | b        | b | a * |
| 4 -> 11 | c        | c | c   |
| 5 -> 12 | -        | - | -   |
| 6 -> 13 | c        | c | c   |
| 7 -> X  | -        | - | -   |
| 8 -> X  | -        | - | -   |

Let - = 000, a = 100, b = 010, c = 001 (based on DX300)

|        | Base (2) | 1     | 4     |
|--------|----------|-------|-------|
| 0 -> 0 | 000      | 000   | 000   |
| 1 -> 1 | 100      | 100   | 100   |
| 2 -> 2 | 010      | 010   | 010   |
| 3 -> 3 | 100      | 010 * | 100   |
| 4 -> 4 | 100      | 100   | 100   |
| 5 -> 5 | 100      | 100   | 100   |
| 6 -> 6 | 000      | 000   | 000   |

| 7 -> X | 000      | 100 * | 000   |
| 8 -> X | 000      | 000   | 010 * |

0, 3, 5 ROM:

|         | Base (3) | 5   | 0     |
|---------|----------|-----|-------|
| 0 -> 7  | 000      | 000 | 000   |
| 1 -> 8  | 100      | 100 | 100   |
| 2 -> 9  | 010      | 010 | 010   |
| 3 -> 10 | 010      | 010 | 100 * |
| 4 -> 11 | 001      | 001 | 001   |
| 5 -> 12 | 000      | 000 | 000   |
| 6 -> 13 | 001      | 001 | 001   |

| 7 -> X  | 000      | 000 | 000   |
| 8 -> X  | 000      | 000 | 000   |

Started on a proof of concept yet its already quite bulky with exception logic:

```
# Wait for request
slp: slx x3

# Save pattern and column to acc/dat
# TODO: We save lines by looking at P pins directly
mov x3 acc # patt
mov x3 dat # col

# If we aren't patterns 7 or 8, look up in ROM
tlt acc 7
+ jmp lookup

# If we are an exception case, then output custom value
teq acc 7
+ teq dat 1
+ mov 100 x3
+ jmp slp
# Another exception case
teq acc 8
+ teq dat 4
+ mov 010 x3
+ jmp slp

# TODO: We are missing lookup itself and else case for 7/8 patterns (i.e. output 000)
lookup: nop
```

Maybe we only read pattern from ROM and directly output to DX300. Then have another controller override DX300 if necessary
