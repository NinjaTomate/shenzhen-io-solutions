# Input variables
# P_BUTTON
# P_SENSOR

# Output variables
# P_INK_K
# P_INK_N

# First iterations
## Thoughts
Need to figure out how to get most common color

Once we have it, convert it to an index (7 indicies)

Read N/K from read only RAM [N_0, K_0, N_1, K_1, ...]

Maybe we convert to index and set RAM value at index

Then on release we perform reads
  But how do we know which one won...
  I guess >= and overwrite `dat` or something
    Also no ties so `>` only

TODO: Need to start at neutral

## Concept
3 controllers:

- Button press detector + RAM writer
    - When button off, send X trigger with NULL to next controller
- Common color calculator
    - On NULL signal from button press detector
    - Read from RAM, use >= to find best index
    - Send X trigger with index to next controller
- Color outputer
    - Jump to read only RAM at specified index
    - Flush next 2 values as N and K
    - Maybe swap order so its (K, N) like diagram

TODO: Use DX300 + MC4000X for last controller to save cost and pins?

TODO: We can also convert P_BUTTON to X_BUTTON via DX300
  but space seems limited

### Mapping logic
Input    Tens #    Offset     Normalize -1 to 0
20-39 -> 2 or 3 -> -1 or 0 -> 0
40-49 -> 4      -> 1       -> 1
50-59 -> 5      -> 2       -> 2
60-69 -> 6      -> 3       -> 3
70-79 -> 7      -> 4       -> 4
80-89 -> 8      -> 5       -> 5

Need to verify: Moving RAM address to -1 moves to 0
  Nope, it jumps to -1 index (in fact, -100 is -2 === -100 modulo 14)
  Thankfully, we should be fine to only use this logic on save
  So either use a `< -1` check or `< 40` check...

TODO: We might not need to X trigger from first controller to second
  We could have second watch button too

TODO: We need to wipe out RAM on LEARN end
  We can prob do that via second controller since we want to read before wipe

Completed color reader, let's document it:

```
# If LEARN is off, then sleep
teq p1 100
- jmp SLEEP

# Read in current sensor
mov p0 acc

# Convert to 0-5 index via our mapping
dgt 1
sub 3
tlt acc 0
+ mov 0 acc

# Save value to be saved to DAT
# DEV: We need to back it up since we lose position due to auto increment
#  Maybe there's some way to walk (14 - 6) spaces efficiently
mov acc dat

# Jump to our index
mov dat x3

# Read our input (auto-increments index)
mov x2 acc

# Update our count
add 1

# Jump to our index again
mov dat x3

# Output our updated count
mov acc x2

# Sleep
SLEEP: slp 1
```

We are out of registers for common compare

TODO: Maybe we can avoid wasting dat by saving last index in next section of RAM

[COUNT_0, COUNT_0_INDEX, COUNT_1, COUNT_1_INDEX, ...]

Even better, use 10's place as count

31 = count 3, index 1

TODO: Verify that dst 100 or 999 sets to 9 still
  It uses 1's place so no it won't work if we get more than 10 of same but let's see what happens...
